#pragma once

#include <atomic>
#include <list>

namespace ptl
{
// Michael-Scott Queue
template <typename T> class msqueue
{
  protected:
    class node_t
    {
      public:
        std::atomic<std::shared_ptr<node_t>> p_next;
        T m_value;

        explicit node_t(const T &value)
        {
            this->p_next.store(nullptr);
            this->m_value = value;
        }

        ~node_t()
        {
            m_value.~T();
        }
    };

    std::atomic<std::shared_ptr<node_t>> p_first;
    std::atomic<std::shared_ptr<node_t>> p_last;

  public:
    explicit msqueue()
    {
        this->p_first = std::make_shared<node_t>(0);
        this->p_last = this->p_first.load();
    }

    ~msqueue()
    {
        auto iterator = p_first.load();
        auto next = iterator->p_next.load();
        while (next != nullptr)
        {
            iterator->p_next.store(nullptr);
            iterator = next;
            next = next->p_next.load();
        }
    }

    void push(const T &value)
    {
        auto node = std::make_shared<node_t>(value);
        while (true)
        {
            auto last = this->p_last.load();
            std::shared_ptr<node_t> temp = nullptr;
            if (last->p_next.compare_exchange_weak(temp, node))
            {
                this->p_last.compare_exchange_weak(last, node);
                return;
            }
            else
            {
                this->p_last.compare_exchange_weak(last, last->p_next.load());
            }
        }
    }

    T pop()
    {
        while (true)
        {
            auto first = this->p_first.load();
            auto firstNext = first->p_next.load();
            auto last = this->p_last.load();
            if (first == last)
            {
                if (firstNext == nullptr)
                {
                    throw std::runtime_error("Container is empty");
                }
                else
                {
                    this->p_last.compare_exchange_weak(last, firstNext);
                }
            }
            else
            {
                auto result = firstNext->m_value;
                if (this->p_first.compare_exchange_weak(first, firstNext))
                {
                    return result;
                }
            }
        }
    }
};
} // namespace ptl