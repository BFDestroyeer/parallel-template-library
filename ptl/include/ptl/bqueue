#pragma once

#include "epochguard"
#include <atomic>
#include <memory>

namespace ptl
{
template <typename T>
class bqueue
{
    const size_t MAX_HOPS = 3;

  protected:
    class pointer_t;

    class node_t
    {
      public:
        std::atomic<pointer_t> p_next;
        T m_value;

        explicit node_t(const T &value)
        {
            this->m_value = value;
        }

        ~node_t()
        {
            m_value.~T();
        }
    };

    class pointer_t
    {
      public:
        node_t* p_node;
        bool m_deleted;
        unsigned m_tag;

        pointer_t() {
            this->p_node = nullptr;
            this->m_deleted = false;
            this->m_tag = 0;
        }

        explicit pointer_t(node_t* node, bool deleted = false, unsigned tag = 0) {
            this->p_node = node;
            this->m_deleted = deleted;
            this->m_tag = tag;
        }

        explicit pointer_t(const T &value, bool deleted = false, unsigned tag = 0) {
            this->p_node = new node_t(value);
            this->m_deleted = deleted;
            this->m_tag = tag;
        }

        bool operator==(const pointer_t&) const = default;
    };

    std::atomic<pointer_t> p_first;
    std::atomic<pointer_t> p_last;

    ptl::epoch_guard<node_t> m_guard;

  private:
    void free_chain(pointer_t& first, pointer_t& new_first, size_t thread_id)
    {
        if (this->p_first.compare_exchange_weak(first, pointer_t(new_first.p_node, false , first.m_tag + 1)))
        {
            while (first.p_node != new_first.p_node)
            {
                auto next = first.p_node->p_next.load();
                this->m_guard.add_to_delete_list(first.p_node, thread_id);
                first = next;
            }
        }
    }

  public:
    bqueue(size_t thread_count) : m_guard(thread_count)
    {
        auto node = new node_t(0);
        this->p_first = pointer_t(node);
        this->p_last = pointer_t(node);
    }

    ~bqueue()
    {
        /*if (this->p_first.load() != this->p_last.load())
        {
            free_chain(this->p_first.load(), this->p_last.load());
        }*/
    }

    void push(const T &value, size_t thread_id = 0)
    {
        this->m_guard.enter(thread_id);
        auto node = new node_t(value);
        while (true)
        {
            auto last = this->p_last.load(std::memory_order_consume);
            auto next = last.p_node->p_next.load(std::memory_order_consume);
            if (last == this->p_last.load())
            {
                if (next.p_node == nullptr)
                {
                    node->p_next = pointer_t(nullptr, false, last.m_tag + 2);
                    if (last.p_node->p_next.compare_exchange_weak(next, pointer_t(node, false, last.m_tag + 1)))
                    {
                        this->p_last.compare_exchange_weak(last, pointer_t(node, false, last.m_tag + 1));
                        this->m_guard.exit(thread_id);
                        return;
                    }
                    next = last.p_node->p_next.load(std::memory_order_consume);
                    while((next.m_tag == last.m_tag + 1) && !(next.m_deleted))
                    {
                        // Back-off
                        node->p_next = next;
                        if (last.p_node->p_next.compare_exchange_weak(next, pointer_t(node, false, last.m_tag + 1)))
                        {
                            this->m_guard.exit(thread_id);
                            return;
                        }
                        next = last.p_node->p_next;
                    }
                }
                else
                {
                    while((next.p_node->p_next.load(std::memory_order_consume).p_node != nullptr) && (this->p_last == last))
                    {
                        next = next.p_node->p_next;
                    }
                }
            }
        }
    }

    T pop(size_t thread_id = 0)
    {
        this->m_guard.enter(thread_id);
        while (true)
        {
            auto first = this->p_first.load();
            auto last = this->p_last.load();
            auto next = first.p_node->p_next.load();
            if (first == this->p_first.load())
            {
                if (first.p_node == last.p_node)
                {
                    if (next.p_node == nullptr)
                    {
                        this->m_guard.exit(thread_id);
                        throw std::runtime_error("Container is empty");
                    }
                    while ((next.p_node->p_next.load().p_node != nullptr) && (this->p_last == last))
                    {
                        next = next.p_node->p_next.load();
                    }
                }
                else
                {
                    auto iterator = first;
                    size_t hops = 0;
                    while ((next.m_deleted && iterator.p_node != last.p_node) && (this->p_first.load() == first))
                    {
                        iterator = next;
                        next = iterator.p_node->p_next;
                        hops++;
                    }
                    if (this->p_first.load() != first){
                        continue;
                    }
                    else if (iterator.p_node == last.p_node)
                    {
                        this->free_chain(first, iterator, thread_id);
                    }
                    else
                    {
                        auto value = next.p_node->m_value;
                        if (iterator.p_node->p_next.compare_exchange_weak(next, pointer_t(next.p_node, true, next.m_tag + 1)))
                        {
                            if (hops >= MAX_HOPS)
                            {
                                this->free_chain(first, next, thread_id);
                            }
                            this->m_guard.exit(thread_id);
                            return value;
                        }
                        // Back-off
                    }
                }
            }
        }
    }
};
}