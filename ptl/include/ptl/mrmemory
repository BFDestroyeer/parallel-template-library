#include "allocator"
#include "mrlock"

#include <intrin.h> //MSVC ONLY!!!

namespace ptl
{
template <typename T, typename Allocator = ptl::allocator<T>> class mrmemory
{
  private:
    using size_type = size_t;

    struct segment
    {
      public:
        T *m_array;
        mutable mrlock m_lock;

        segment() = delete;

        constexpr explicit segment(size_type count) : m_lock(count)
        {
            this->m_array = Allocator().allocate(count);
        }

        constexpr ~segment()
        {
            delete[] this->m_array;
        }
    };

    segment **m_segments;
    size_type m_capacity = 0;

    static size_type segment_index(size_type raw_index)
    {
        unsigned long result;
        _BitScanReverse64(&result, raw_index); // ZERO!!!!
        return result;
    }

    static size_type local_index(size_type raw_index)
    {
        auto segment_id = segment_index(raw_index);
        size_type mask = 1 << segment_id;
        auto result = raw_index xor mask;
        return result;
    }

  public:
    constexpr mrmemory() = delete;

    constexpr explicit mrmemory(size_type count)
    {
        this->m_segments = new segment *[64]; // Can store more than can be addressed with 64 bit pointer

        size_type index = 0, current_segment_capacity = 1;
        while (this->m_capacity < count)
        {
            this->m_segments[index] = new segment(current_segment_capacity);
            this->m_capacity += current_segment_capacity;
            index++;
            current_segment_capacity = current_segment_capacity << 1;
        }
    }

    constexpr ~mrmemory()
    {
        size_type segment_count = this->segment_index(this->m_capacity);
        for (size_type i = 0; i < segment_count; i++)
        {
            this->m_segments[i]->~segment();
        }
        delete[] this->m_segments;
    }

    constexpr T at(size_type index) const
    {
        if (index >= this->m_capacity)
        {
            throw std::out_of_range("Index is out of range");
        }

        auto segment_id = this->segment_index(index);
        auto local_id = this->local_index(index);

        auto handle = this->m_segments[segment_id]->m_lock.random_access_lock(index);
        auto result = this->m_segments[segment_id]->m_array[local_id];
        this->m_segments[segment_id]->m_lock.unlock(handle);
        return result;
    }

    void write(size_type index, T value)
    {
        if (index >= this->m_capacity)
        {
            throw std::out_of_range("Index is out of range");
        }

        auto segment_id = this->segment_index(index);
        auto local_id = this->local_index(index);

        auto handle = this->m_segments[segment_id]->m_lock.random_access_lock(index);
        this->m_segments[segment_id]->m_array[local_id] = value;
        this->m_segments[segment_id]->m_lock.unlock(handle);
    }
};
} // namespace ptl