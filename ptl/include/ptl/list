#pragma once

#define BUILD_PARALLEL 1

#include <future>

#include "ptl/allocator"

namespace ptl
{
template <typename T, typename Allocator = ptl::allocator<T>> class list
{
  protected:
    class Node
    {
      public:
        T m_value;

        Node *p_previous = nullptr;
        Node *p_next = nullptr;

        Node() = default;

        explicit Node(const T &value, Node *previous = nullptr, Node *next = nullptr)
        {
            this->m_value = value;
            this->p_previous = previous;
            this->p_next = next;
        }

        ~Node()
        {
            m_value.~T();
        }
    };

    using size_type = size_t;

    size_type m_count = 0;

    Node *p_first = nullptr;
    Node *p_last = nullptr;

  public:
    explicit list() = default;

    explicit list(size_type count)
    {
#if BUILD_PARALLEL
        if (count == 0)
        {
            return;
        }
        Node **local_first;
#pragma omp parallel default(none), shared(count, local_first)
        {
            auto thread_id = omp_get_thread_num();
            auto threads_count = omp_get_num_threads();
            if (thread_id == 0)
            {
                local_first = new Node *[threads_count];
            }
#pragma omp barrier
            size_type local_count;
            if (thread_id != 0)
            {
                local_count = count / threads_count;
            }
            else
            {
                local_count = count - (count / threads_count) * (threads_count - 1);
            }
            local_first[thread_id] = nullptr;

            Node *previous_node;
            if (local_count != 0)
            {
                local_first[thread_id] = new Node();
                previous_node = local_first[thread_id];
                for (size_type i = 1; i < local_count; i++)
                {
                    auto node = new Node(i);
                    previous_node->p_next = node;
                    node->p_previous = previous_node;
                    previous_node = node;
                }
                if (thread_id == 0)
                {
                    this->p_first = local_first[thread_id];
                }
                if (thread_id == threads_count - 1)
                {
                    this->p_last = previous_node;
                }
                if (thread_id == 0 && count / threads_count == 0)
                {
                    this->p_last = previous_node;
                }
            }
#pragma omp barrier
            if (local_count != 0)
            {
                if (thread_id != threads_count - 1)
                {
                    previous_node->p_next = local_first[thread_id + 1];
                    if (local_first[thread_id + 1] != nullptr)
                    {
                        local_first[thread_id + 1]->p_previous = previous_node;
                    }
                }
            }
        }
        delete[] local_first;
        this->m_count = count;
#else
        if (count == 0)
        {
            return;
        }
        this->p_first = new Node();
        Node *previous_node = this->p_first;
        for (size_type i = 1; i < count; i++)
        {
            auto node = new Node();
            previous_node->p_next = node;
            node->p_previous = previous_node;
            previous_node = node;
        }
        this->p_last = previous_node;
        this->m_count = count;
#endif
    }

    constexpr ~list()
    {
        this->clear();
    }

    // Capacity
    [[nodiscard]] bool empty() const noexcept
    {
        return this->m_count == 0;
    }

    [[nodiscard]] size_type size() const noexcept
    {
        return this->m_count;
    }

    // Modifiers
    void clear() noexcept
    {
#if BUILD_PARALLEL
#pragma omp parallel num_threads(2) default(none)
        {
            auto thread_number = omp_get_thread_num();
            if (thread_number == 0)
            {
                Node *current_node = this->p_first;
                for (size_type i = 0; i < this->m_count / 2; i++)
                {
                    Node *next_node = current_node->p_next;
                    delete current_node;
                    current_node = next_node;
                }
            }
            else
            {
                Node *current_node = this->p_last;
                for (size_type i = 0; i < this->m_count - (this->m_count / 2); i++)
                {
                    Node *previous_node = current_node->p_previous;
                    delete current_node;
                    current_node = previous_node;
                }
            }
        }
        this->p_first = nullptr;
        this->p_last = nullptr;
        this->m_count = 0;
#else
        Node *current_node = this->p_first;
        while (current_node != nullptr)
        {
            Node *next_node = current_node->p_next;
            delete current_node;
            current_node = next_node;
        }
        this->m_count = 0;
#endif
    }

    std::future<void> clear_async()
    {
        return std::async(&list::clear, this);
    }

    void push_back(const T &value)
    {
        if (this->m_count != 0)
        {
            auto node = new Node(value, this->p_last);
            this->p_last->p_next = node;
            node->p_previous = this->p_last;
            this->p_last = node;
        }
        else
        {
            auto node = new Node(value);
            this->p_first = node;
            this->p_last = node;
        }
        this->m_count++;
    }

    // Operations
    size_type unique()
    {
        return this->unique(std::equal_to<>());
    }

    template <typename BinaryPredicate> size_type unique(BinaryPredicate predicate)
    {
        size_type old_count = this->m_count;
        if (this->m_count == 0)
        {
            return 0;
        }
        Node *current_node = this->p_first;
        Node *next_node;
        while (current_node->p_next != nullptr)
        {
            next_node = current_node->p_next;
            if (predicate(current_node->m_value, next_node->m_value))
            {
                current_node->p_next = next_node->p_next;
                next_node->p_previous = current_node;
                delete next_node;
                this->m_count--;
            }
            else
            {
                current_node = current_node->p_next;
            }
        }
        this->p_last = current_node;
        return old_count - this->m_count;
    }

    std::future<size_type> unique_async()
    {
        auto unique = static_cast<size_type (list::*)()>(&list::unique);
        return std::async(unique, this);
    }

    template <typename BinaryPredicate> std::future<size_type> unique_async(BinaryPredicate predicate)
    {
        auto unique = static_cast<size_type (list::*)(BinaryPredicate)>(&list::unique);
        return std::async(unique, this, predicate);
    }
};
} // namespace ptl