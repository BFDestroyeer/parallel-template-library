#pragma once

#define BUILD_PARALLEL 1

#include <future>
#include <thread>

#include "ptl/allocator"

namespace ptl
{
template <typename T, typename Allocator = ptl::allocator<T>> class list
{
  protected:
    class Node
    {
      public:
        T m_value;

        Node *p_previous = nullptr;
        Node *p_next = nullptr;

        Node() = default;

        explicit Node(const T &value, Node *previous = nullptr, Node *next = nullptr)
        {
            this->m_value = value;
            this->p_previous = previous;
            this->p_next = next;
        }

        ~Node()
        {
            m_value.~T();
        }
    };

    using size_type = size_t;

    const unsigned c_threads_count = std::thread::hardware_concurrency();

    size_type m_count = 0;

    Node *p_first = nullptr;
    Node *p_last = nullptr;

    Node **p_local_firsts = new Node *[this->c_threads_count] {};

  public:
    explicit list() = default;

    explicit list(size_type count)
    {
#if BUILD_PARALLEL
        if (count == 0)
        {
            return;
        }
#pragma omp parallel num_threads(this->c_threads_count) default(none), shared(count)
        {
            auto thread_id = omp_get_thread_num();
#pragma omp barrier
            size_type local_count;
            if (thread_id != 0)
            {
                local_count = count / this->c_threads_count;
            }
            else
            {
                local_count = count - (count / this->c_threads_count) * (this->c_threads_count - 1);
            }
            this->p_local_firsts[thread_id] = nullptr;

            Node *previous_node;
            if (local_count != 0)
            {
                this->p_local_firsts[thread_id] = new Node();
                previous_node = this->p_local_firsts[thread_id];
                for (size_type i = 1; i < local_count; i++)
                {
                    auto node = new Node(i);
                    previous_node->p_next = node;
                    node->p_previous = previous_node;
                    previous_node = node;
                }
                if (thread_id == 0)
                {
                    this->p_first = this->p_local_firsts[thread_id];
                }
                if (thread_id == this->c_threads_count - 1)
                {
                    this->p_last = previous_node;
                }
                if (thread_id == 0 && count / this->c_threads_count == 0)
                {
                    this->p_last = previous_node;
                }
            }
#pragma omp barrier
            if (local_count != 0)
            {
                if (thread_id != this->c_threads_count - 1)
                {
                    previous_node->p_next = this->p_local_firsts[thread_id + 1];
                    if (this->p_local_firsts[thread_id + 1] != nullptr)
                    {
                        this->p_local_firsts[thread_id + 1]->p_previous = previous_node;
                    }
                }
            }
        }
        this->m_count = count;
#else
        if (count == 0)
        {
            return;
        }
        this->p_first = new Node();
        Node *previous_node = this->p_first;
        for (size_type i = 1; i < count; i++)
        {
            auto node = new Node(i);
            previous_node->p_next = node;
            node->p_previous = previous_node;
            previous_node = node;
        }
        this->p_last = previous_node;
        this->m_count = count;
#endif
    }

    constexpr ~list()
    {
        this->clear();
    }

    // Capacity
    [[nodiscard]] bool empty() const noexcept
    {
        return this->m_count == 0;
    }

    [[nodiscard]] size_type size() const noexcept
    {
        return this->m_count;
    }

    // Modifiers
    void clear() noexcept
    {
#if BUILD_PARALLEL
#pragma omp parallel num_threads(this->c_threads_count) default(none)
        {
            auto thread_id = omp_get_thread_num();
            if (this->p_local_firsts[thread_id] != nullptr && thread_id != 0)
            {
                this->p_local_firsts[thread_id]->p_previous->p_next = nullptr;
            }
#pragma omp barrier
            if (this->p_local_firsts[thread_id] != nullptr)
            {
                Node *current_node = this->p_local_firsts[thread_id];
                while (current_node != nullptr)
                {
                    Node *next_node = current_node->p_next;
                    delete current_node;
                    current_node = next_node;
                }
                this->p_local_firsts[thread_id] = nullptr;
            }
        }
        this->p_first = nullptr;
        this->p_last = nullptr;
        this->m_count = 0;
#else
        Node *current_node = this->p_first;
        while (current_node != nullptr)
        {
            Node *next_node = current_node->p_next;
            delete current_node;
            current_node = next_node;
        }
        this->p_first = nullptr;
        this->p_last = nullptr;
        this->m_count = 0;
#endif
    }

    std::future<void> clear_async()
    {
        return std::async(&list::clear, this);
    }

    void push_back(const T &value)
    {
        if (this->m_count != 0)
        {
            auto node = new Node(value, this->p_last);
            this->p_last->p_next = node;
            node->p_previous = this->p_last;
            this->p_last = node;
        }
        else
        {
            auto node = new Node(value);
            this->p_first = node;
            this->p_last = node;
        }
        // local first movement
        if (this->m_count < this->c_threads_count)
        {
            this->p_local_firsts[this->m_count] = this->p_last;
        }
        else
        {
            if (this->m_count + 1 % this->c_threads_count != 0)
            {
                for (unsigned i = 1; i < this->c_threads_count; i++)
                {
                    this->p_local_firsts[i] = this->p_local_firsts[i]->p_next;
                }
            }
            else
            {
                for (unsigned i = 1; i < this->c_threads_count; i++)
                {
                    for (unsigned j = 0; j < this->c_threads_count - 1 - i; j++)
                    {
                        this->p_local_firsts[i] = this->p_local_firsts[i]->p_previous;
                    }
                }
            }
        }
        this->m_count++;
    }

    // Operations
    size_type unique()
    {
        return this->unique(std::equal_to<>());
    }

    template <typename BinaryPredicate> size_type unique(BinaryPredicate predicate)
    {
        size_type old_count = this->m_count;
        if (this->m_count == 0)
        {
            return 0;
        }
        Node *current_node = this->p_first;
        Node *next_node;
        while (current_node->p_next != nullptr)
        {
            next_node = current_node->p_next;
            if (predicate(current_node->m_value, next_node->m_value))
            {
                current_node->p_next = next_node->p_next;
                next_node->p_previous = current_node;
                delete next_node;
                this->m_count--;
            }
            else
            {
                current_node = current_node->p_next;
            }
        }
        this->p_last = current_node;
        return old_count - this->m_count;
    }

    std::future<size_type> unique_async()
    {
        auto unique = static_cast<size_type (list::*)()>(&list::unique);
        return std::async(unique, this);
    }

    template <typename BinaryPredicate> std::future<size_type> unique_async(BinaryPredicate predicate)
    {
        auto unique = static_cast<size_type (list::*)(BinaryPredicate)>(&list::unique);
        return std::async(unique, this, predicate);
    }
};
} // namespace ptl