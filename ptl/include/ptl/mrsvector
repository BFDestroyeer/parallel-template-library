#include "allocator"
#include "mrlock"

#include <intrin.h> //MSVC ONLY!!!
#include <mutex>

#include "amutex"

namespace ptl
{
template <typename T, typename Allocator = ptl::allocator<T>> class mrsvector
{
  private:
    using size_type = size_t;

    struct segment_t
    {
      public:
        T *m_array;
        mutable mrlock m_lock;

        segment_t() = delete;

        constexpr explicit segment_t(size_type count) : m_lock(count + 1)
        {
            this->m_array = Allocator().allocate(count);
        }

        constexpr ~segment_t()
        {
            delete[] this->m_array;
        }
    };

    std::atomic<std::shared_ptr<segment_t>> m_segments[64];
    std::atomic<size_type> m_count = 0;
    std::atomic<size_type> m_capacity = 0;

    mutable ptl::amutex m_count_mutex;

    static size_type segment_index(size_type raw_index)
    {
        unsigned long result;
        auto is_non_zero = _BitScanReverse64(&result, raw_index + 1);
        return result;
    }

    static size_type local_index(size_type raw_index)
    {
        if (raw_index == 0)
        {
            return 0;
        }
        auto segment_id = segment_index(raw_index);
        size_type mask = 1 << segment_id;
        auto result = raw_index + 1 xor mask;
        return result;
    }

  public:
    constexpr mrsvector() = delete;

    constexpr explicit mrsvector(size_type count)
    {
        size_type index = 0, current_segment_capacity = 1;
        while (this->m_capacity < count)
        {
            this->m_segments[index] = std::make_shared<segment_t>(current_segment_capacity);
            this->m_capacity += current_segment_capacity;
            index++;
            current_segment_capacity = current_segment_capacity << 1;
        }
        this->m_count = count;
    }

    constexpr mrsvector(const mrsvector &other)
    {
    }

    ~mrsvector() = default;

    // Element access
    constexpr T at(size_type index) const
    {
        if (index >= this->m_capacity)
        {
            throw std::out_of_range("Index is out of range"); // TODO: Remove
        }

        auto segment_id = this->segment_index(index);
        auto local_id = this->local_index(index);

        auto segment = this->m_segments[segment_id].load();

        if (segment.get() == nullptr)
        {
            throw std::out_of_range("Index is out of range");
        }

        auto handle = segment->m_lock.random_access_lock(local_id);
        auto result = segment->m_array[local_id];
        segment->m_lock.unlock(handle);
        return result;
    }

    void write(size_type index, T value)
    {
        if (index >= this->m_capacity)
        {
            throw std::out_of_range("Index is out of range");
        }

        auto segment_id = this->segment_index(index);
        auto local_id = this->local_index(index);

        auto segment = this->m_segments[segment_id].load();
        auto handle = segment->m_lock.random_access_lock(local_id);
        segment->m_array[local_id] = value;
        segment->m_lock.unlock(handle);
    }

    // Capacity
    [[nodiscard]] bool empty() const
    {
        return this->m_count == 0;
    }

    [[nodiscard]] size_type size() const
    {
        return this->m_count;
    }

    [[nodiscard]] size_type capacity() const noexcept
    {
        return this->m_capacity;
    }

    constexpr void resize(size_type count)
    {
        if (this->m_capacity < count) // Increase vector capacity
        {
            size_type segmentIndex = this->segment_index(this->m_capacity.load());
            size_type targetSegmentIndex = this->segment_index(count - 1) + 1;
            size_type current_segment_capacity = 1 << segmentIndex;
            std::shared_ptr<segment_t> temp = nullptr;
            while (segmentIndex < targetSegmentIndex)
            {
                if (this->m_segments[segmentIndex].compare_exchange_weak(
                        temp, std::make_shared<segment_t>(current_segment_capacity)))
                {
                    this->m_capacity += current_segment_capacity;
                }
                segmentIndex++;
                current_segment_capacity = current_segment_capacity << 1;
            }
        }
        /*else // Decrease vector capacity
        {
            size_type first = 0;
            if (count != 0)
            {
                first = this->segment_index(count - 1) + 1;
            }
            size_type last = this->segment_index(this->m_capacity);

            for (size_type i = first; i < last; i++)
            {
                auto segment = this->m_segments[i].load();
                segment->m_lock.all_lock();
                this->m_capacity -= 1 << i;
                this->m_segments[i] = nullptr;
            }
        }*/
    }

    // Modifiers
    constexpr void push_back(const T &value)
    {
        this->m_count_mutex.lock();
        auto count = this->m_count.load();
        if (count == this->m_capacity.load())
        {
            this->resize(this->m_capacity + 1);
        }

        auto segment_id = this->segment_index(count - 1);
        auto local_id = this->local_index(count - 1);

        auto segment = this->m_segments[segment_id].load();
        auto handle = segment->m_lock.random_access_lock(local_id);
        segment->m_array[local_id] = value;
        this->m_count.store(count + 1);
        segment->m_lock.unlock(handle);
        this->m_count_mutex.unlock();
    }

    constexpr void pop_back()
    {
        this->m_count_mutex.lock();
        auto segment_id = this->segment_index(this->m_count - 1);
        auto local_id = this->local_index(this->m_count - 1);

        auto segment = this->m_segments[segment_id].load();
        auto handle = segment->m_lock.random_access_lock(local_id);
        segment->m_array[local_id].~T();
        this->m_count--;
        segment->m_lock.unlock(handle);
        this->m_count_mutex.unlock();
    }
};
} // namespace ptl